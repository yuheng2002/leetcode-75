"""
LeetCode 334: Increasing Triplet Subsequence
Link: https://leetcode.com/problems/increasing-triplet-subsequence/

Idea:
- Brute-force ideas (e.g., sort and then try to recover index order, or try all pairs)
  are either logically flawed (sorting destroys original indices) or too slow (quadratic).

- The linear-time/constant-space trick:
  Maintain two thresholds while scanning left-to-right:
  `first`  = the smallest value seen so far
  `second` = the smallest value > first seen so far
  If we ever see an element > second, we’ve found first < second < current → return True.

Why `<=` instead of `<`?
- Using `<` can misclassify equals. For example, with [1,1,1],
  the third 1 would fall into the final `else` branch and incorrectly return True.
- Using `<=` lets us update `first`/`second` with later-equal elements so indices keep the proper order.

Time Complexity: O(n)
Space Complexity: O(1)
"""

class Solution:
    def increasingTriplet(self, nums: List[int]) -> bool:
        # the tricky part of this problem comes down to finding a simplified algorithm
        # personally, the more natural and intution-based way of solving it is to sort the list, and then go through 
        # each element from the smallest to the largest, to see if the any of the two subsequently larger elements also
        # have subsequently larger indexes. However, this approach has a time complexity of O(n^2). 
        # This apporach is NOT efficient as the complexity grows exponentially as the size of the list increases

        # Now, a better apporach can be generated by better understanding what conditions we really need to meet for an
        # output to be true. That is, for any element x, there exists a larger element with a bigger index, and another
        # larger element with a even bigger index. 

        # If we focus on the smallest and second smallest elements, and iterate through the rest of the list, it is 
        # guaranteed that, if we can find another element that is bigger than second smallest element, then an
        # increasing triplet is found. 

        # this step is not mandatory, but it can save some runtime by checking if the list even have at least 3     
        # elements in it
        if len(nums) < 3:
            return False

        # this creates two variables with values being positive infinity, this makes sure that, whatever value the
        # elements in the list have, there is always at least a smallest and second smallest, if there are at least
        # 3 elements in it
        first = float('inf')
        second = float('inf')

        # the tricky part of this algorithm is that, sometimes first could be updated to the value of an element at a 
        # bigger index than the index of the second smallest element, then if next comes an element that's larger than
        # both first and second, intuitively, I thought this would break the i < j < k condition the problem asks for.
        # However, this is not to be worried about, because, the key about this algorithm is that, in any scenario,
        # the existance of a second smallest 
        # element already guarantees that, there must be a smallest element in the list also with a smaller index
        # due to the fact that we are iterating through the list from index 0. 
        for element in nums:
            # note that here must use <=, instead of <.
            # using < would cause bugs if we are dealing with a list with all elements having the same value, such as 
            # [1, 1, 1, 1, 1]
            # then because 1 is not less than 1, at the third element, the code under the else part would return True
            # but the expected answer is False
            if element <= first:
                first = element
            elif element <= second:
                second = element
            else:
                return True
        
        return False
